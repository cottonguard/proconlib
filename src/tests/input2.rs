use crate::input2::*;

#[test]
fn i32() {
    let cases: [(&[u8], i32); 12] = [
        (b"0", 0),
        (b"1", 1),
        (b"100", 100),
        (b"12345", 12345),
        (b"12345678", 12345678),
        (b"2147483647", 2147483647),
        (b"-0", 0),
        (b"-1", -1),
        (b"-100", -100),
        (b"-12345", -12345),
        (b"-12345678", -12345678),
        (b"-2147483648", -2147483648),
    ];
    for (s, expected) in cases {
        assert_eq!(i32::parse_bytes(s), expected);
    }
}

#[test]
fn i64() {
    let cases: [(&[u8], i64); 14] = [
        (b"0", 0),
        (b"1", 1),
        (b"100", 100),
        (b"12345", 12345),
        (b"12345678", 12345678),
        (b"123456789012345678", 123456789012345678),
        (b"9223372036854775807", 9223372036854775807),
        (b"-0", 0),
        (b"-1", -1),
        (b"-100", -100),
        (b"-12345", -12345),
        (b"-12345678", -12345678),
        (b"-123456789012345678", -123456789012345678),
        (b"-9223372036854775808", -9223372036854775808),
    ];
    for (s, expected) in cases {
        assert_eq!(i64::parse_bytes(s), expected);
    }
}

#[test]
fn input() {
    let cases: [(&[u8], &[i32]); 4] = [
        (
            b"1 12345 2  \t\n 123456789  0",
            &[1, 12345, 2, 123456789, 0],
        ),
        (b"1", &[1]),
        (b"", &[]),
        (b"   123   ", &[123]),
    ];
    for (s, e) in cases {
        let mut ss = Input::with_capacity(&s[..], 1);
        for (x, e) in e.iter().copied().zip(ss.seq(100)) {
            assert_eq!(x, e);
        }
    }
}

#[test]
fn array() {
    let s = b"1 2 3 4 5 6 7 8";
    let mut ss = Input::new(&s[..]);
    assert_eq!(ss.input::<[i32; 1]>(), [1]);
    assert_eq!(ss.input::<[i32; 2]>(), [2, 3]);
    assert_eq!(ss.input::<[i32; 0]>(), []);
    assert_eq!(ss.input::<[i32; 2]>(), [4, 5]);
}
